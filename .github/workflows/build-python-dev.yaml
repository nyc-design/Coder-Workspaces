name: Build & Push python-dev (multi-arch, native runners) - GHCR

on:
  push:
    branches:
      - main
    paths:
      - "workspace-images/python-dev/**"
      - ".github/workflows/build-python-dev.yaml"
  workflow_dispatch:
  workflow_run:
    workflows: ["Build & Push base-dev (multi-arch, native runners) - GHCR"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAMESPACE: workspace-images
  IMAGE_NAME: python-dev

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runs_on: ubuntu-latest
          - platform: linux/arm64
            runs_on: ubuntu-24.04-arm   # native ARM64 runner
    runs-on: ${{ matrix.runs_on }}

    steps:
      - uses: actions/checkout@v4

      # ── Auth to GitHub Container Registry ─────────────────────────────
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute image coords
        run: |
          echo "IMG=${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAMESPACE }}/${{ env.IMAGE_NAME }}" >> $GITHUB_ENV
          echo "SHA_SHORT=${GITHUB_SHA::7}" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Build single-arch on native runner, push by digest (optimized)
      - name: Build & push by digest (${{ matrix.platform }})
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: workspace-images/python-dev/Dockerfile
          platforms: ${{ matrix.platform }}
          tags: ${{ env.IMG }}
          outputs: type=image,push-by-digest=true,name-canonical=true,push=true
          cache-from: type=gha,ref=${{ env.IMG }}:buildcache
          cache-to: type=gha,ref=${{ env.IMG }}:buildcache,mode=max
          provenance: false
          sbom: false

      - name: Export digest file
        run: |
          mkdir -p ${{ runner.temp }}/digests
          digest="${{ steps.build.outputs.digest }}"
          touch "${{ runner.temp }}/digests/${digest#sha256:}"

      - name: Upload digest artifact
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.platform == 'linux/amd64' && 'linux-amd64' || 'linux-arm64' }}
          path: ${{ runner.temp }}/digests/*
          retention-days: 1

  merge:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - uses: actions/checkout@v4

      # ── Auth to GitHub Container Registry ─────────────────────────────
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute image coords
        run: |
          echo "IMG=${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAMESPACE }}/${{ env.IMAGE_NAME }}" >> $GITHUB_ENV
          echo "SHA_SHORT=${GITHUB_SHA::7}" >> $GITHUB_ENV

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/digests
          pattern: digests-*
          merge-multiple: true

      - name: Create and push multi-arch manifest
        working-directory: ${{ runner.temp }}/digests
        run: |
          set -eux
          refs=""
          for d in *; do
            refs="$refs ${IMG}@sha256:${d}"
          done
          docker buildx imagetools create \
            -t "${IMG}:latest" \
            -t "${IMG}:sha-${SHA_SHORT}" \
            $refs

      - name: Inspect final image
        run: docker buildx imagetools inspect "${IMG}:latest"

      - name: Clean up old sha-* versions in GHCR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          API="https://api.github.com"
          OWNER="${GITHUB_REPOSITORY_OWNER}"
          PACKAGE_PATH="${IMAGE_NAMESPACE}/${IMAGE_NAME}"
          PACKAGE_NAME_ENCODED="$(printf '%s' "${PACKAGE_PATH}" | sed 's#/#%2F#g')"

          echo "Package: ${OWNER}/${PACKAGE_PATH}"

          # Fetch up to 100 versions
          curl -sS \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "${API}/users/${OWNER}/packages/container/${PACKAGE_NAME_ENCODED}/versions?per_page=100" \
            > versions.json

          if ! jq -e 'length > 0' versions.json >/dev/null 2>&1; then
            echo "No versions found; skipping cleanup."
            exit 0
          fi

          # Save id -> tags mapping
          jq -r '
            .[]
            | {id, tags: (.metadata.container.tags // [])}
            | "\(.id) \(.tags | join(","))"
          ' versions.json > id_tags.txt

          # Find *all* sha-* versions (newest first)
          jq -r '
            [ .[]
              | {id, created_at, tags: (.metadata.container.tags // [])}
              | select(any(.tags[]?; startswith("sha-")))
            ]
            | sort_by(.created_at) | reverse
            | .[] | .id
          ' versions.json > sha_ids_all.txt

          if ! [ -s sha_ids_all.txt ]; then
            echo "No sha-* versions found; nothing to delete."
            exit 0
          fi

          echo "sha-* versions (newest first):"
          nl -ba sha_ids_all.txt

          # Keep only the FIRST (newest) one
          NEWEST_SHA_ID="$(head -n 1 sha_ids_all.txt)"

          CURRENT_SHA_TAG="sha-${SHA_SHORT}"

          echo "Newest sha-* version ID: ${NEWEST_SHA_ID}"
          echo "Current build sha tag: ${CURRENT_SHA_TAG}"

          # Decide what to delete
          : > delete_ids.txt
          while read -r vid; do
            # Skip the newest sha-* version
            if [ "${vid}" = "${NEWEST_SHA_ID}" ]; then
              echo "Keeping newest sha-* version: ${vid}"
              continue
            fi

            # Get the tag list for vid
            tags="$(grep "^${vid} " id_tags.txt | cut -d' ' -f2-)"

            # Never delete 'latest'
            if printf "%s" "${tags}" | grep -q "latest"; then
              echo "Keeping version ${vid} (tag: latest)"
              continue
            fi

            # Never delete the current build's sha tag
            if printf "%s" "${tags}" | grep -q "${CURRENT_SHA_TAG}"; then
              echo "Keeping version ${vid} (tag: ${CURRENT_SHA_TAG})"
              continue
            fi

            # Otherwise, mark for deletion
            echo "${vid}" >> delete_ids.txt
          done < sha_ids_all.txt

          if ! [ -s delete_ids.txt ]; then
            echo "Nothing to delete."
            exit 0
          fi

          echo "Deleting old sha-* versions:"
          sed 's/^/  /' delete_ids.txt

          # Perform deletion
          while read -r id; do
            echo "Deleting version id=${id}"
            curl -sS -X DELETE \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              "${API}/users/${OWNER}/packages/container/${PACKAGE_NAME_ENCODED}/versions/${id}" \
              || echo "Failed to delete version ${id}, continuing..."
          done < delete_ids.txt